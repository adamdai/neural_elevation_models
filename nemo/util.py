import torch
import numpy as np
import plotly.graph_objects as go
import plotly.express as px

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
TORCH_PI = torch.tensor(np.pi, device=device)

def gradient(y, x, grad_outputs=None):
    if grad_outputs is None:
        grad_outputs = torch.ones_like(y)
    grad = torch.autograd.grad(y, [x], grad_outputs=grad_outputs, create_graph=True)[0]
    return grad


def wrap_angle_torch(angle):
    """Wrap angle to [-pi, pi] range"""
    return ((angle + TORCH_PI) % (2 * TORCH_PI)) - TORCH_PI


##### ------------------- PLOTTING ------------------- #####

def plot_surface(fig, x, y, z, colorscale='Viridis', no_axes=False):
    fig.add_trace(go.Surface(x=x, y=y, z=z, colorscale=colorscale))
    fig.update_layout(width=1200, height=900, scene_aspectmode='data')
    if no_axes:
        fig.update_layout(scene=dict(xaxis=dict(visible=False), yaxis=dict(visible=False), zaxis=dict(visible=False)))
    return fig


def plot_path_3d(fig, x, y, z, color='red', markersize=3, linewidth=3):
    fig.add_trace(go.Scatter3d(x=x, y=y, z=z, mode='markers+lines', marker=dict(size=markersize, color=color),
                           line=dict(color=color, width=linewidth)))
    return fig



def path_metrics(path):
    """
    Parameters
    ---------
    path: torch tensor (N, 3)
    """
    print(f'Path length: {len(path)}')

    # Calculate the length of the path
    path_length_2d = 0
    path_length_3d = 0
    path_xy = path[:,:2]
    for i in range(len(path)-1):
        path_length_2d += torch.norm(path_xy[i+1] - path_xy[i])
        path_length_3d += torch.norm(path[i+1] - path[i])
    print(f'2D distance: {path_length_2d}')
    print(f'3D distance: {path_length_3d}')

    # Calculate the sum of absolute height deltas along the path
    height_diff = 0
    path_zs = path[:,2]
    for i in range(len(path)-1):
        height_diff += torch.abs(path_zs[i+1] - path_zs[i])
    print(f'Height delta sum: {height_diff.item()}')

    # Calculate smoothness as jerk
    jerk = 0
    for i in range(1, len(path)-1):
        jerk += torch.norm(path[i+1] - 2*path[i] + path[i-1])
    print(f'Average jerk: {jerk.item()/len(path)}')



def parse_colmap_point_cloud(filename):
    """
    Parameters
    ----------
    filename: str
        Path to .txt file generated by colmap

    Returns
    -------
    points: np.array (N, 3)
        3D points
    colors: np.array (N, 3)
        RGB colors
    """
    points = []
    colors = []
    with open(filename, 'r') as file:
        lines = file.readlines()
        for line in lines[3:]:  # Skip the first 3 lines which are comments
            if line.strip():  # Skip empty lines
                data = line.strip().split()
                point = [float(data[i]) for i in range(1, 4)]  # Extract X, Y, Z
                color = [int(data[i]) for i in range(4, 7)]  # Extract R, G, B
                points.append(point)
                colors.append(color)
    return np.array(points), np.array(colors)