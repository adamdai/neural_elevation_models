"""Miscellaneous utility functions

"""


import torch
import numpy as np
import requests
import urllib
import concurrent.futures

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
TORCH_PI = torch.tensor(np.pi, device=device)


#%========================= -- Pytorch -- =========================%#

def gradient(y, x, grad_outputs=None):
    """Compute the gradient of y with respect to x"""
    if grad_outputs is None:
        grad_outputs = torch.ones_like(y)
    grad = torch.autograd.grad(y, [x], grad_outputs=grad_outputs, create_graph=True)[0]
    return grad


def grid_2d(N, bounds):
    """Grid of 2D (N x N) points"""
    xs = torch.linspace(bounds[0], bounds[1], N, device=device)
    ys = torch.linspace(bounds[2], bounds[3], N, device=device)
    XY_grid = torch.meshgrid(xs, ys, indexing='xy')
    XY_grid = torch.stack(XY_grid, dim=-1)
    positions = XY_grid.reshape(-1, 2)
    return positions, XY_grid


def wrap_angle_torch(angle):
    """Wrap angle to [-pi, pi] range"""
    return ((angle + TORCH_PI) % (2 * TORCH_PI)) - TORCH_PI


#%========================= -- Coordinates -- =========================%#

# TODO
def nemo_to_airsim(coord, params):
    """Convert NEMo coordinates to AirSim coordinates
    
    """
    coord /= params['dataparser_scale']
    R = params['dataparser_transform'][:3,:3]
    t = params['dataparser_transform'][:3,3]
    coord = (coord - t) @ R
    coord = coord[:,[1,0,2]]
    coord[:,2] *= -1
    coord += params['spiral_center']
    return coord


# TODO
def airsim_to_nemo(coord, params):
    """Convert AirSim coordinates to NEMo coordinates
    
    Parameters
    ----------
    coord: torch tensor (N, 3)
        AirSim coordinates
    params: dict
        Parameters for the conversion
    
    """
    coord -= params['spiral_center']  # Shift by spiral center offset
    coord = coord[:,[1,0,2]]  # Swap x and y
    coord[:,2] *= -1  # Flip z
    R = params['dataparser_transform'][:3,:3]
    t = params['dataparser_transform'][:3,3]
    coord = coord @ R.T + t
    coord *= params['dataparser_scale']
    return coord


#%========================= -- Path -- =========================%#

def path_metrics(path):
    """
    Parameters
    ---------
    path: torch tensor (N, 3)
    """
    print(f'Num points: {len(path)}')

    # Calculate the length of the path
    path_length_2d = 0
    path_length_3d = 0
    path_xy = path[:,:2]
    for i in range(len(path)-1):
        path_length_2d += torch.norm(path_xy[i+1] - path_xy[i])
        path_length_3d += torch.norm(path[i+1] - path[i])
    print(f'2D distance: {path_length_2d}')
    print(f'3D distance: {path_length_3d}')

    # Calculate the sum of absolute height deltas along the path
    height_diff = 0
    path_zs = path[:,2]
    for i in range(len(path)-1):
        height_diff += torch.abs(path_zs[i+1] - path_zs[i])
    print(f'Height delta sum: {height_diff.item()}')

    # Average along-path slope 
    slope = 0
    delta_zs = path_zs[1:] - path_zs[:-1]
    delta_xys = path_xy[1:] - path_xy[:-1]
    slopes = delta_zs / torch.norm(delta_xys)
    print("Average along-path slope: ", torch.abs(slopes).mean().item())
    # Min, max (TODO)

    # Average lateral slope (TODO - need to use heightmap)


    # Calculate smoothness as jerk
    jerk = 0
    for i in range(1, len(path)-1):
        jerk += torch.norm(path[i+1] - 2*path[i] + path[i-1])
    print(f'Average jerk: {jerk.item()/len(path)}')


#%========================= -- DEMs -- =========================%#

def parse_colmap_point_cloud(filename):
    """
    Parameters
    ----------
    filename: str
        Path to .txt file generated by colmap

    Returns
    -------
    points: np.array (N, 3)
        3D points
    colors: np.array (N, 3)
        RGB colors
    """
    points = []
    colors = []
    with open(filename, 'r') as file:
        lines = file.readlines()
        for line in lines[3:]:  # Skip the first 3 lines which are comments
            if line.strip():  # Skip empty lines
                data = line.strip().split()
                point = [float(data[i]) for i in range(1, 4)]  # Extract X, Y, Z
                color = [int(data[i]) for i in range(4, 7)]  # Extract R, G, B
                points.append(point)
                colors.append(color)
    return np.array(points), np.array(colors)


def elevation_function(df, lat_column, lon_column):
    """Query service using lat, lon. Add the elevation values as a new column.
    
    Uses parallel threads for faster querying.
    
    """
    url = 'https://epqs.nationalmap.gov/v1/json?'
    
    # Function to query elevation for a single point
    def query_elevation(lat, lon):
        params = {
            'output': 'json',
            'x': lon,
            'y': lat,
            'units': 'Meters'
        }
        result = requests.get((url + urllib.parse.urlencode(params)))
        return result.json()['value']
    
    # Parallelize elevation queries
    with concurrent.futures.ThreadPoolExecutor() as executor:
        # Map latitudes and longitudes to query function
        elevations = list(executor.map(query_elevation, df[lat_column], df[lon_column]))
    
    # Add elevations to DataFrame
    df['elev_meters'] = elevations